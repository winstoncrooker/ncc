<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My Collection - Vinyl Vault</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&family=Montserrat:wght@300;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="css/auth.css" />
  <style>
    .upload-section {
      max-width: 800px;
      margin: 0 auto;
      text-align: center;
      padding: 40px 20px;
    }

    .upload-section h1 {
      font-size: 2rem;
      color: #1db954;
      margin-bottom: 20px;
    }

    .alpha-badge {
      display: inline-block;
      background: #1db954;
      color: #0e0e0e;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 20px;
    }

    .upload-instructions {
      background: #1a1a1a;
      border: 2px dashed #1db954;
      border-radius: 10px;
      padding: 30px;
      margin: 30px 0;
    }

    .upload-instructions p {
      color: #aaa;
      line-height: 1.6;
      margin: 10px 0;
    }

    .upload-instructions strong {
      color: #1db954;
    }

    .upload-box {
      background: #1a1a1a;
      border: 3px dashed #555;
      border-radius: 15px;
      padding: 50px 30px;
      margin: 30px 0;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .upload-box:hover {
      border-color: #1db954;
      background: #222;
    }

    .upload-box.drag-over {
      border-color: #1db954;
      background: #222;
      transform: scale(1.02);
    }

    .upload-box i {
      font-size: 3rem;
      color: #1db954;
      margin-bottom: 15px;
    }

    .upload-box p {
      color: #aaa;
      margin: 10px 0;
    }

    .upload-box .browse-btn {
      display: inline-block;
      background: #1db954;
      color: #0e0e0e;
      padding: 12px 30px;
      border-radius: 25px;
      font-weight: 600;
      margin-top: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .upload-box .browse-btn:hover {
      background: #1ed760;
      transform: scale(1.05);
    }

    #fileInput {
      display: none;
    }

    .search-section {
      max-width: 600px;
      margin: 30px auto;
    }

    .search-box {
      width: 100%;
      padding: 15px 20px;
      border: 2px solid #333;
      border-radius: 25px;
      background: #1a1a1a;
      color: #eee;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    .search-box:focus {
      outline: none;
      border-color: #1db954;
      background: #222;
    }

    .collection-list {
      max-width: 800px;
      margin: 30px auto;
      background: #1a1a1a;
      border-radius: 15px;
      padding: 30px;
    }

    .collection-list h2 {
      color: #1db954;
      margin-bottom: 20px;
      font-size: 1.5rem;
    }

    /* Album Grid Styles */
    .collection-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 20px;
      padding: 20px 0;
    }

    .album-card {
      background: #1a1a1a;
      border-radius: 12px;
      transition: all 0.3s ease;
      position: relative;
    }

    .album-card:hover {
      transform: translateY(-8px);
      box-shadow: 0 15px 40px rgba(29, 185, 84, 0.3);
    }

    .album-card .cover-container {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      background: #222;
      overflow: hidden;
      border-radius: 12px 12px 0 0;
    }

    .album-card .cover {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.3s ease;
    }

    .album-card:hover .cover {
      transform: scale(1.1);
    }

    .album-card .loading-cover {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
      color: #555;
      font-size: 3rem;
    }

    .album-card .album-info {
      padding: 12px;
      text-align: center;
    }

    .album-card .artist {
      color: #1db954;
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .album-card .album-title {
      color: #ccc;
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .album-card .price {
      color: #1db954;
      font-weight: 600;
      font-size: 0.85rem;
      margin-top: 6px;
    }

    .album-card .delete-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(211, 47, 47, 0.9);
      color: white;
      border: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 10;
      pointer-events: auto;
    }

    .album-card:hover .delete-btn {
      opacity: 1;
    }

    .album-card .delete-btn:hover {
      background: #f44336;
      transform: scale(1.1);
    }

    @media (max-width: 600px) {
      .collection-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }

    .empty-state i {
      font-size: 4rem;
      margin-bottom: 20px;
    }

    .status-message {
      max-width: 600px;
      margin: 20px auto;
      padding: 15px 25px;
      border-radius: 10px;
      text-align: center;
      font-weight: 600;
      display: none;
    }

    .status-message.success {
      background: rgba(29, 185, 84, 0.2);
      border: 2px solid #1db954;
      color: #1db954;
    }

    .status-message.error {
      background: rgba(211, 47, 47, 0.2);
      border: 2px solid #d32f2f;
      color: #f44336;
    }

    .clear-all-btn {
      background: #d32f2f;
      color: white;
      border: none;
      padding: 10px 25px;
      border-radius: 20px;
      cursor: pointer;
      font-weight: 600;
      margin-top: 20px;
      transition: all 0.3s ease;
    }

    .clear-all-btn:hover {
      background: #f44336;
      transform: scale(1.05);
    }

    @media (max-width: 800px) {
      .upload-section h1 {
        font-size: 1.5rem;
      }

      .collection-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
    }

    /* AI Chat Styles */
    .chat-container {
      max-width: 800px;
      margin: 30px auto;
      background: #1a1a1a;
      border-radius: 15px;
      overflow: hidden;
      border: 2px solid #333;
    }

    .chat-header {
      background: linear-gradient(135deg, #1db954 0%, #169c46 100%);
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .chat-header h3 {
      margin: 0;
      color: #000;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .chat-toggle {
      background: none;
      border: none;
      color: #000;
      font-size: 1.5rem;
      cursor: pointer;
      transition: transform 0.3s;
    }

    .chat-toggle.collapsed {
      transform: rotate(180deg);
    }

    .chat-body {
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .chat-body.collapsed {
      max-height: 0;
    }

    .chat-messages {
      height: 300px;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .chat-message {
      max-width: 85%;
      padding: 12px 16px;
      border-radius: 15px;
      line-height: 1.5;
      font-size: 0.95rem;
    }

    .chat-message.user {
      background: #1db954;
      color: #000;
      align-self: flex-end;
      border-bottom-right-radius: 5px;
    }

    .chat-message.assistant {
      background: #333;
      color: #fff;
      align-self: flex-start;
      border-bottom-left-radius: 5px;
    }

    .chat-message.thinking {
      background: #333;
      color: #888;
      align-self: flex-start;
      font-style: italic;
    }

    .chat-message.error {
      background: #d32f2f;
      color: #fff;
      align-self: center;
    }

    .chat-input-container {
      display: flex;
      gap: 10px;
      padding: 15px 20px;
      background: #222;
      border-top: 1px solid #333;
    }

    .chat-input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #333;
      border-radius: 25px;
      background: #1a1a1a;
      color: #fff;
      font-size: 0.95rem;
      font-family: 'Montserrat', sans-serif;
    }

    .chat-input:focus {
      outline: none;
      border-color: #1db954;
    }

    .chat-input::placeholder {
      color: #666;
    }

    .chat-send {
      padding: 12px 24px;
      background: #1db954;
      color: #000;
      border: none;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      font-family: 'Montserrat', sans-serif;
    }

    .chat-send:hover {
      background: #1ed760;
      transform: scale(1.05);
    }

    .chat-send:disabled {
      background: #555;
      cursor: not-allowed;
      transform: none;
    }

    .api-key-setup {
      padding: 20px;
      text-align: center;
    }

    .api-key-setup p {
      color: #aaa;
      margin-bottom: 15px;
      font-size: 0.9rem;
    }

    .api-key-input {
      width: 100%;
      max-width: 400px;
      padding: 12px 16px;
      border: 2px solid #333;
      border-radius: 8px;
      background: #0e0e0e;
      color: #fff;
      font-family: monospace;
      margin-bottom: 15px;
    }

    .api-key-input:focus {
      outline: none;
      border-color: #1db954;
    }

    .api-key-btn {
      padding: 10px 25px;
      background: #1db954;
      color: #000;
      border: none;
      border-radius: 20px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .api-key-btn:hover {
      background: #1ed760;
    }

    .typing-indicator {
      display: flex;
      gap: 5px;
      padding: 15px;
    }

    .typing-indicator span {
      width: 8px;
      height: 8px;
      background: #1db954;
      border-radius: 50%;
      animation: typing 1.4s infinite;
    }

    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-indicator span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-10px); }
    }
  </style>
</head>
<body>
  <nav id="mainNav">
    <button class="hamburger" id="hamburger" aria-label="Menu">
      <span></span><span></span><span></span>
    </button>
    <div class="nav-links" id="navLinks">
      <a href="index.html">Home</a>
      <a href="stats.html">üìä Stats</a>
      <a href="mycollection.html">üìù My Collection</a>
      <a href="genre.html?genre=rock">Rock</a>
      <a href="genre.html?genre=blues">Blues</a>
      <a href="genre.html?genre=metal">Metal</a>
      <a href="genre.html?genre=pop">Pop</a>
      <a href="genre.html?genre=jazz">Jazz</a>
      <a href="genre.html?genre=soul">Soul</a>
      <a href="genre.html?genre=funk">Funk</a>
      <a href="genre.html?genre=country">Country</a>
      <a href="genre.html?genre=hiphop">Hip-Hop</a>
      <a href="genre.html?genre=folk">Folk</a>
      <a href="genre.html?genre=classical">Classical</a>
      <a href="genre.html?genre=experimental">Experimental</a>
      <a href="genre.html?genre=comedy">Comedy</a>
    </div>
  </nav>

  <!-- Auth Header -->
  <div id="authContainer" class="auth-container">
    <!-- Login button or user profile will be inserted here by auth.js -->
  </div>

  <section class="upload-section">
    <h1>Add Your Own Collection</h1>
    <div class="alpha-badge">ALPHA MODE</div>
    
    <div class="upload-instructions">
      <p><strong>Upload a PDF or TXT file with your collection</strong></p>
      <p>Format: <strong>Artist - Album</strong> (one per line)</p>
      <p style="color: #1db954; margin-top: 15px;"><strong>Example:</strong></p>
      <p style="background: #222; padding: 15px; border-radius: 8px; font-family: monospace; line-height: 1.8;">
        Nirvana - Nevermind<br>
        Funkadelic - Maggot Brain<br>
        Pink Floyd - Dark Side of the Moon
      </p>
      <p style="color: #aaa; font-size: 0.9rem; margin-top: 10px;">Each entry must be on its own line with Artist - Album format</p>
    </div>

    <div id="statusMessage" class="status-message"></div>

    <div class="upload-box" id="uploadBox">
      <div style="font-size: 3rem; margin-bottom: 15px;">üìÑ</div>
      <p style="font-size: 1.1rem; color: #eee; margin-bottom: 5px;">Drag & Drop your PDF or TXT file here</p>
      <p style="color: #666;">or</p>
      <div class="browse-btn" onclick="document.getElementById('fileInput').click()">
        Browse Files
      </div>
      <input type="file" id="fileInput" accept=".txt,.pdf" />
    </div>

    <div class="search-section" id="searchSection" style="display: none;">
      <input 
        type="text" 
        id="searchBox" 
        class="search-box" 
        placeholder="üîç Search for artist or album..."
      />
    </div>

    <div class="collection-list" id="collectionList" style="display: none;">
      <h2>Your Collection (<span id="collectionCount">0</span> albums) <span id="collectionValue" style="font-size: 0.8em; color: #1db954;"></span></h2>
      <div class="collection-grid" id="collectionItems"></div>
      <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
        <button class="clear-all-btn" style="background: #1db954;" onclick="fetchAllAlbumData(true)">Refresh Covers & Prices</button>
        <button class="clear-all-btn" onclick="clearCollection()">Clear All</button>
      </div>
    </div>

    <div class="empty-state" id="emptyState">
      <div style="font-size: 4rem; margin-bottom: 20px;">üéµ</div>
      <p>Upload a PDF or TXT file to start building your collection</p>
    </div>

    <!-- AI Chat Assistant -->
    <div class="chat-container" id="chatContainer">
      <div class="chat-header" onclick="toggleChat()">
        <h3>ü§ñ AI Collection Assistant</h3>
        <button class="chat-toggle" id="chatToggle">‚ñº</button>
      </div>
      <div class="chat-body" id="chatBody">
        <!-- API Key Setup (shown if no key) -->
        <div class="api-key-setup" id="apiKeySetup">
          <p>Enter your Together.ai API key to enable AI features</p>
          <input
            type="password"
            class="api-key-input"
            id="apiKeyInput"
            placeholder="Enter Together.ai API key..."
          />
          <br>
          <button class="api-key-btn" onclick="saveApiKey()">Save API Key</button>
          <p style="margin-top: 15px; font-size: 0.8rem;">
            <a href="https://api.together.ai" target="_blank" style="color: #1db954;">Get a free API key from Together.ai ‚Üí</a>
          </p>
        </div>

        <!-- Chat Interface (shown after key is set) -->
        <div id="chatInterface" style="display: none;">
          <div class="chat-messages" id="chatMessages">
            <div class="chat-message assistant">
              Hi! I'm your vinyl collection assistant powered by Apriel. Ask me anything about your collection, or tell me about albums you want to add!
            </div>
          </div>
          <div class="chat-input-container">
            <input
              type="text"
              class="chat-input"
              id="chatInput"
              placeholder="Ask about your collection..."
              onkeypress="if(event.key === 'Enter') sendMessage()"
            />
            <button class="chat-send" id="chatSend" onclick="sendMessage()">Send</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <footer>¬© 2025 Vinyl Vault - My Collection (Alpha)</footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="js/config.js"></script>
  <script src="js/auth.js"></script>
  <script>
    // Set up PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    let userCollection = [];

    // Load collection from localStorage on page load
    window.addEventListener('DOMContentLoaded', () => {
      loadCollection();
      setupEventListeners();
      setupAuth();
    });

    // Set up authentication UI
    function setupAuth() {
      const authContainer = document.getElementById('authContainer');
      if (!authContainer) return;

      function updateAuthUI() {
        authContainer.innerHTML = '';

        if (Auth.isAuthenticated()) {
          const user = Auth.getUser();
          const profile = document.createElement('div');
          profile.className = 'user-profile';

          if (user?.picture) {
            profile.innerHTML = `
              <img src="${user.picture}" alt="${user.name || user.email}" class="user-avatar" />
              <span class="user-name">${user.name || user.email}</span>
              <button class="logout-btn" onclick="Auth.logout(); location.reload();">Sign out</button>
            `;
          } else {
            profile.innerHTML = `
              <span class="user-name">${user?.email || 'User'}</span>
              <button class="logout-btn" onclick="Auth.logout(); location.reload();">Sign out</button>
            `;
          }
          authContainer.appendChild(profile);
        } else {
          const loginBtn = Auth.createLoginButton('Sign in with Google', window.location.href);
          authContainer.appendChild(loginBtn);
        }
      }

      // Initial render
      updateAuthUI();

      // Listen for auth events
      window.addEventListener('auth:success', updateAuthUI);
      window.addEventListener('auth:logout', updateAuthUI);
    }

    function setupEventListeners() {
      const uploadBox = document.getElementById('uploadBox');
      const fileInput = document.getElementById('fileInput');
      const searchBox = document.getElementById('searchBox');

      // File input change
      fileInput.addEventListener('change', handleFileSelect);

      // Drag and drop
      uploadBox.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadBox.classList.add('drag-over');
      });

      uploadBox.addEventListener('dragleave', () => {
        uploadBox.classList.remove('drag-over');
      });

      uploadBox.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadBox.classList.remove('drag-over');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          handleFile(files[0]);
        }
      });

      // Search functionality
      searchBox.addEventListener('input', (e) => {
        filterCollection(e.target.value);
      });

      // Hamburger menu
      const hamburger = document.getElementById('hamburger');
      const navLinks = document.getElementById('navLinks');
      
      if (hamburger && navLinks) {
        hamburger.addEventListener('click', () => {
          hamburger.classList.toggle('active');
          navLinks.classList.toggle('active');
          document.body.classList.toggle('menu-open');
        });
        
        document.addEventListener('click', (e) => {
          if (!e.target.closest('nav')) {
            hamburger.classList.remove('active');
            navLinks.classList.remove('active');
            document.body.classList.remove('menu-open');
          }
        });
        
        navLinks.querySelectorAll('a').forEach(link => {
          link.addEventListener('click', () => {
            hamburger.classList.remove('active');
            navLinks.classList.remove('active');
            document.body.classList.remove('menu-open');
          });
        });
      }
    }

    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (file) {
        handleFile(file);
      }
    }

    async function handleFile(file) {
      const fileName = file.name.toLowerCase();
      const isPDF = fileName.endsWith('.pdf');
      const isTXT = fileName.endsWith('.txt');

      if (!isPDF && !isTXT) {
        showMessage('Please upload a .pdf or .txt file', 'error');
        return;
      }

      showMessage(isPDF ? 'Extracting text from PDF...' : 'Processing file...', 'success');

      try {
        let text;
        if (isPDF) {
          text = await extractTextFromPDF(file);
        } else {
          text = await file.text();
        }

        const { entries, totalLines, skippedLines } = parseEntriesWithStats(text);

        if (entries.length === 0) {
          showMessage('No valid entries found. Use format: Artist - Album (one per line)', 'error');
          return;
        }

        userCollection = entries;
        saveCollection();
        displayCollection();

        let message = `Successfully imported ${entries.length} albums!`;
        if (skippedLines > 0) {
          message += ` (${skippedLines} lines skipped)`;
        }
        showMessage(message, 'success');

        // Auto-fetch album covers and prices from Discogs
        onAlbumsAdded();
      } catch (error) {
        console.error('Error processing file:', error);
        showMessage('Error processing file. Please try again.', 'error');
      }
    }

    async function extractTextFromPDF(file) {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
      let fullText = '';
      const totalPages = pdf.numPages;

      for (let i = 1; i <= totalPages; i++) {
        showMessage(`Extracting page ${i} of ${totalPages}...`, 'success');
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();

        // Extract text while preserving line breaks based on Y position
        let lastY = null;
        let lineText = '';

        for (const item of textContent.items) {
          // Get Y position from transform matrix (item.transform[5])
          const currentY = item.transform[5];

          // If Y position changed significantly, it's a new line
          if (lastY !== null && Math.abs(currentY - lastY) > 5) {
            fullText += lineText.trim() + '\n';
            lineText = '';
          }

          lineText += item.str + ' ';
          lastY = currentY;
        }

        // Add the last line of the page
        if (lineText.trim()) {
          fullText += lineText.trim() + '\n';
        }
      }

      showMessage('Processing extracted text...', 'success');
      return fullText;
    }

    function parseEntriesWithStats(text) {
      const lines = text.split('\n');
      const entries = [];
      let totalLines = 0;
      let skippedLines = 0;

      for (let line of lines) {
        line = line.trim();
        if (!line) continue;

        totalLines++;

        // Only accept "Artist - Album" format
        const match = line.match(/^(.+?)\s*-\s*(.+)$/);
        if (match) {
          const artist = match[1].trim();
          const album = match[2].trim();
          if (artist && album) {
            entries.push({ artist, album });
          } else {
            skippedLines++;
          }
        } else {
          skippedLines++;
        }
      }

      return { entries, totalLines, skippedLines };
    }

    function displayCollection() {
      const collectionList = document.getElementById('collectionList');
      const emptyState = document.getElementById('emptyState');
      const searchSection = document.getElementById('searchSection');

      if (userCollection.length === 0) {
        collectionList.style.display = 'none';
        searchSection.style.display = 'none';
        emptyState.style.display = 'block';
        return;
      }

      collectionList.style.display = 'block';
      searchSection.style.display = 'block';
      emptyState.style.display = 'none';

      renderCollection(userCollection);
    }

    function renderCollection(items) {
      const collectionItems = document.getElementById('collectionItems');
      const collectionCount = document.getElementById('collectionCount');
      const collectionValue = document.getElementById('collectionValue');

      collectionCount.textContent = items.length;
      collectionItems.innerHTML = '';

      // Calculate total value
      let totalValue = 0;
      items.forEach(entry => {
        if (entry.price && typeof entry.price === 'number') {
          totalValue += entry.price;
        }
      });

      if (totalValue > 0) {
        collectionValue.textContent = `‚Ä¢ Est. Value: $${totalValue.toFixed(2)}`;
      } else {
        collectionValue.textContent = '';
      }

      items.forEach((entry, index) => {
        const card = document.createElement('div');
        card.className = 'album-card';

        const coverUrl = entry.cover || '';
        const priceDisplay = entry.price ? `$${entry.price.toFixed(2)}` : '';
        const isLoading = entry.loading === true;

        card.innerHTML = `
          <div class="cover-container">
            ${coverUrl
              ? `<img class="cover" src="${coverUrl}" alt="${escapeHtml(entry.album)}" onerror="this.parentElement.innerHTML='<div class=\\'loading-cover\\'>üíø</div>'">`
              : `<div class="loading-cover">${isLoading ? '‚è≥' : 'üíø'}</div>`
            }
          </div>
          <div class="album-info">
            <div class="artist" title="${escapeHtml(entry.artist)}">${escapeHtml(entry.artist)}</div>
            <div class="album-title" title="${escapeHtml(entry.album)}">${escapeHtml(entry.album)}</div>
            ${priceDisplay ? `<div class="price">${priceDisplay}</div>` : ''}
          </div>
          <button class="delete-btn" onclick="deleteItem(${index})" title="Remove">√ó</button>
        `;
        collectionItems.appendChild(card);
      });
    }

    function filterCollection(query) {
      if (!query) {
        renderCollection(userCollection);
        return;
      }

      const lowerQuery = query.toLowerCase();
      const filtered = userCollection.filter(entry => 
        entry.artist.toLowerCase().includes(lowerQuery) ||
        entry.album.toLowerCase().includes(lowerQuery)
      );

      renderCollection(filtered);
    }

    function deleteItem(index) {
      console.log('deleteItem called with index:', index);
      userCollection.splice(index, 1);
      saveCollection();
      displayCollection();
      showMessage('Album removed', 'success');
    }

    function clearCollection() {
      console.log('clearCollection called');
      userCollection = [];
      saveCollection();
      displayCollection();
      document.getElementById('searchBox').value = '';
      showMessage('Collection cleared', 'success');
    }

    function saveCollection() {
      localStorage.setItem('userCollection', JSON.stringify(userCollection));
    }

    function loadCollection() {
      const saved = localStorage.getItem('userCollection');
      if (saved) {
        try {
          userCollection = JSON.parse(saved);
          displayCollection();
          // Auto-fetch missing album data on page load
          const hasMissingData = userCollection.some(entry => !entry.cover);
          if (hasMissingData) {
            onAlbumsAdded();
          }
        } catch (e) {
          console.error('Error loading collection:', e);
          userCollection = [];
        }
      }
    }

    function showMessage(text, type) {
      const message = document.getElementById('statusMessage');
      message.textContent = text;
      message.className = `status-message ${type}`;
      message.style.display = 'block';
      
      setTimeout(() => {
        message.style.display = 'none';
      }, 4000);
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================
    // Discogs API Integration (via Caching Server)
    // ============================================

    // Use local server for caching (falls back to direct API if server unavailable)
    const CACHE_SERVER_URL = 'http://localhost:5001';
    let useLocalServer = true;

    // Direct Discogs API (fallback)
    const DISCOGS_API_URL = 'https://api.discogs.com';
    const DISCOGS_KEY = 'yRxzvHyveKiFOEHuwmcW';
    const DISCOGS_SECRET = 'GnnPcnLGovdJLMfMyEpaSRoXOsRqojBr';

    // Rate limiting for direct Discogs API
    let lastDiscogsRequest = 0;
    const DISCOGS_RATE_LIMIT = 1100;

    async function waitForRateLimit() {
      const now = Date.now();
      const timeSinceLastRequest = now - lastDiscogsRequest;
      if (timeSinceLastRequest < DISCOGS_RATE_LIMIT) {
        await new Promise(resolve => setTimeout(resolve, DISCOGS_RATE_LIMIT - timeSinceLastRequest));
      }
      lastDiscogsRequest = Date.now();
    }

    // Search via caching server (preferred)
    async function searchViaServer(artist, album) {
      const url = `${CACHE_SERVER_URL}/api/discogs/search?artist=${encodeURIComponent(artist)}&album=${encodeURIComponent(album)}`;

      try {
        const response = await fetch(url);
        if (!response.ok) {
          if (response.status === 404) return null;
          throw new Error(`Server error: ${response.status}`);
        }
        return await response.json();
      } catch (error) {
        console.log('Cache server unavailable, falling back to direct API');
        useLocalServer = false;
        return null;
      }
    }

    // Direct Discogs search (fallback)
    async function searchDiscogsDirect(artist, album) {
      await waitForRateLimit();

      const query = encodeURIComponent(`${artist} ${album}`);
      const url = `${DISCOGS_API_URL}/database/search?q=${query}&type=release&key=${DISCOGS_KEY}&secret=${DISCOGS_SECRET}`;

      try {
        const response = await fetch(url, {
          headers: { 'User-Agent': 'VinylVault/1.0' }
        });

        if (!response.ok) return null;

        const data = await response.json();
        if (!data.results?.length) return null;

        const bestMatch = data.results.find(r =>
          r.title.toLowerCase().includes(artist.toLowerCase()) &&
          r.title.toLowerCase().includes(album.toLowerCase())
        ) || data.results[0];

        return {
          id: bestMatch.id,
          cover: bestMatch.cover_image || bestMatch.thumb,
          title: bestMatch.title,
          year: bestMatch.year
        };
      } catch (error) {
        console.error('Discogs search error:', error);
        return null;
      }
    }

    // Get price from direct API (fallback)
    async function getDiscogsPriceDirect(releaseId) {
      await waitForRateLimit();

      try {
        const url = `${DISCOGS_API_URL}/releases/${releaseId}?key=${DISCOGS_KEY}&secret=${DISCOGS_SECRET}`;
        const response = await fetch(url, {
          headers: { 'User-Agent': 'VinylVault/1.0' }
        });

        if (!response.ok) return null;
        const data = await response.json();
        return data.lowest_price || null;
      } catch (error) {
        return null;
      }
    }

    // Fetch album data (uses server cache when available)
    async function fetchAlbumData(index) {
      const entry = userCollection[index];
      if (!entry || entry.cover) return;

      entry.loading = true;
      renderCollection(userCollection);

      try {
        let result = null;

        // Try caching server first
        if (useLocalServer) {
          result = await searchViaServer(entry.artist, entry.album);
        }

        // Fallback to direct API
        if (!result && !useLocalServer) {
          result = await searchDiscogsDirect(entry.artist, entry.album);
          if (result) {
            const price = await getDiscogsPriceDirect(result.id);
            result.price = price;
          }
        }

        if (result) {
          entry.cover = result.cover;
          entry.discogsId = result.id;
          entry.year = result.year;
          if (result.price) entry.price = result.price;
        }
      } catch (error) {
        console.error('Error fetching album data:', error);
      }

      entry.loading = false;
      saveCollection();
      renderCollection(userCollection);
    }

    // Fetch data for all albums (forceRefresh=true will re-fetch even if cover exists)
    async function fetchAllAlbumData(forceRefresh = false) {
      console.log('fetchAllAlbumData called, forceRefresh:', forceRefresh);

      let albumsToFetch;
      if (forceRefresh) {
        // Clear existing data and re-fetch all
        userCollection.forEach(entry => {
          delete entry.cover;
          delete entry.price;
          delete entry.discogsId;
          delete entry.year;
        });
        saveCollection();
        displayCollection();
        albumsToFetch = userCollection.map((entry, index) => ({ entry, index }));
      } else {
        albumsToFetch = userCollection
          .map((entry, index) => ({ entry, index }))
          .filter(({ entry }) => !entry.cover && !entry.loading);
      }

      if (albumsToFetch.length === 0) {
        showMessage('All albums already have data. Click again to force refresh.', 'success');
        return;
      }

      showMessage(`Fetching data for ${albumsToFetch.length} album(s)...`, 'success');

      for (const { index } of albumsToFetch) {
        await fetchAlbumData(index);
      }

      showMessage(`Album data updated!`, 'success');
    }

    // Auto-fetch data when albums are added
    function onAlbumsAdded() {
      // Small delay to let UI update first
      setTimeout(() => {
        fetchAllAlbumData();
      }, 500);
    }

    // ============================================
    // AI Chat Assistant Functions (Together.ai)
    // ============================================

    const TOGETHER_API_URL = 'https://api.together.xyz/v1/chat/completions';
    const CHAT_MODEL = 'meta-llama/Llama-3.3-70B-Instruct-Turbo';
    const TOGETHER_API_KEY = 'cd6f547c5977a88af60b786907b065bfb293faab06dc78d35c50fe230f249161';
    let chatHistory = [];

    // Initialize chat on page load
    function initChat() {
      // API key is pre-configured, show chat interface directly
      document.getElementById('apiKeySetup').style.display = 'none';
      document.getElementById('chatInterface').style.display = 'block';
    }

    // Toggle chat panel
    function toggleChat() {
      const chatBody = document.getElementById('chatBody');
      const chatToggle = document.getElementById('chatToggle');
      chatBody.classList.toggle('collapsed');
      chatToggle.classList.toggle('collapsed');
    }

    // Save API key
    function saveApiKey() {
      const apiKey = document.getElementById('apiKeyInput').value.trim();
      if (!apiKey) {
        alert('Please enter a valid API key');
        return;
      }
      localStorage.setItem('togetherApiKey', apiKey);
      document.getElementById('apiKeySetup').style.display = 'none';
      document.getElementById('chatInterface').style.display = 'block';
      addMessage('API key saved! How can I help you with your collection?', 'assistant');
    }

    // Add message to chat
    function addMessage(text, role) {
      const messagesDiv = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${role}`;
      messageDiv.textContent = text;
      messagesDiv.appendChild(messageDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Add typing indicator
    function showTyping() {
      const messagesDiv = document.getElementById('chatMessages');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'chat-message thinking';
      typingDiv.id = 'typingIndicator';
      typingDiv.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
      messagesDiv.appendChild(typingDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Remove typing indicator
    function hideTyping() {
      const typing = document.getElementById('typingIndicator');
      if (typing) typing.remove();
    }

    // Build system prompt with collection context
    function buildSystemPrompt() {
      let collectionContext = '';

      if (userCollection.length > 0) {
        collectionContext = `\n\nThe user's vinyl collection currently contains ${userCollection.length} albums:\n`;
        userCollection.forEach((item, i) => {
          collectionContext += `${i + 1}. ${item.artist} - ${item.album}\n`;
        });
      } else {
        collectionContext = '\n\nThe user has not uploaded any albums to their collection yet.';
      }

      return `You are a helpful vinyl record collection assistant for "Vinyl Vault". You help users manage their record collections.

CRITICAL RULES:
- Keep responses SHORT and friendly (1-3 sentences max)
- NEVER guess or assume album/artist names you're unsure about
- If ANY part of a request is unclear, ASK FOR CLARIFICATION before acting

ADDING ALBUMS - ONLY when user explicitly asks to ADD:
- Use [ADD_ALBUM: Artist Name - Album Name] tag ONLY when user says "add", "put in", "include", etc.
- NEVER use ADD_ALBUM when giving recommendations or suggestions
- If user asks "what should I get?" or "recommend something" - just tell them, do NOT add it
- Example request: "Add Nevermind" ‚Üí [ADD_ALBUM: Nirvana - Nevermind]

REMOVING ALBUMS - ONLY when user explicitly asks to REMOVE:
- Use [REMOVE_ALBUM: Artist Name - Album Name] tag ONLY when user says "remove", "delete", "take out", etc.
- Example: "Remove Abbey Road" ‚Üí [REMOVE_ALBUM: The Beatles - Abbey Road]

RECOMMENDATIONS:
- When user asks for recommendations, suggestions, or "what should I get" - just TELL them the recommendation
- Do NOT use ADD_ALBUM tag for recommendations
- Example: "What do you recommend?" ‚Üí "Based on your collection, you might enjoy Led Zeppelin IV!"
- Only add it if they then say "add that" or "yes add it"

WHEN CONFUSED:
- ASK for clarification instead of guessing
- "I'm not sure which album you mean. Could you give me the artist and album name?"

Keep your response concise and natural.${collectionContext}`;
    }

    // Parse AI response for album additions
    function parseAlbumAdditions(response) {
      const albumPattern = /\[ADD_ALBUM:\s*(.+?)\s*-\s*(.+?)\]/g;
      const albums = [];
      let match;

      while ((match = albumPattern.exec(response)) !== null) {
        const artist = match[1].trim();
        const album = match[2].trim();
        // Only add if both artist and album are valid (not empty, not just punctuation)
        if (artist && album && artist.length > 1 && album.length > 1 &&
            !/^[\s\-\.\,\?\!]+$/.test(artist) && !/^[\s\-\.\,\?\!]+$/.test(album)) {
          albums.push({ artist, album });
        }
      }

      return albums;
    }

    // Add albums from chat response
    function addAlbumsFromChat(albums) {
      let addedCount = 0;

      for (const album of albums) {
        // Check if album already exists
        const exists = userCollection.some(
          item => item.artist.toLowerCase() === album.artist.toLowerCase() &&
                  item.album.toLowerCase() === album.album.toLowerCase()
        );

        if (!exists) {
          userCollection.push(album);
          addedCount++;
        }
      }

      if (addedCount > 0) {
        saveCollection();
        displayCollection();
        // Auto-fetch album covers and prices from Discogs
        onAlbumsAdded();
      }

      return addedCount;
    }

    // Parse AI response for album removals
    function parseAlbumRemovals(response) {
      const albumPattern = /\[REMOVE_ALBUM:\s*(.+?)\s*-\s*(.+?)\]/g;
      const albums = [];
      let match;

      while ((match = albumPattern.exec(response)) !== null) {
        const artist = match[1].trim();
        const album = match[2].trim();
        // Only process if both artist and album are valid
        if (artist && album && artist.length > 1 && album.length > 1 &&
            !/^[\s\-\.\,\?\!]+$/.test(artist) && !/^[\s\-\.\,\?\!]+$/.test(album)) {
          albums.push({ artist, album });
        }
      }

      return albums;
    }

    // Remove albums from chat response
    function removeAlbumsFromChat(albums) {
      let removedCount = 0;

      for (const albumToRemove of albums) {
        const index = userCollection.findIndex(
          item => item.artist.toLowerCase() === albumToRemove.artist.toLowerCase() &&
                  item.album.toLowerCase() === albumToRemove.album.toLowerCase()
        );

        if (index !== -1) {
          userCollection.splice(index, 1);
          removedCount++;
        }
      }

      if (removedCount > 0) {
        saveCollection();
        displayCollection();
      }

      return removedCount;
    }

    // Send message to Together.ai API
    async function sendMessage() {
      const input = document.getElementById('chatInput');
      const sendBtn = document.getElementById('chatSend');
      const userMessage = input.value.trim();

      if (!userMessage) return;

      const apiKey = TOGETHER_API_KEY;

      // Add user message to chat
      addMessage(userMessage, 'user');
      input.value = '';
      sendBtn.disabled = true;

      // Add to history
      chatHistory.push({ role: 'user', content: userMessage });

      // Show typing indicator
      showTyping();

      try {
        const response = await fetch(TOGETHER_API_URL, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: CHAT_MODEL,
            messages: [
              { role: 'system', content: buildSystemPrompt() },
              ...chatHistory.slice(-10) // Keep last 10 messages for context
            ],
            max_tokens: 256,
            temperature: 0.2
          })
        });

        hideTyping();

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.error?.message || `API error: ${response.status}`);
        }

        const data = await response.json();
        const assistantMessage = data.choices[0]?.message?.content || 'Sorry, I could not generate a response.';

        // Parse for album additions and removals BEFORE cleaning
        const albumsToAdd = parseAlbumAdditions(assistantMessage);
        const albumsToRemove = parseAlbumRemovals(assistantMessage);

        // Clean up thinking tags, internal processing, and command tags from display
        let cleanedMessage = assistantMessage
          // Remove thinking tags and their contents
          .replace(/<think>[\s\S]*?<\/think>/gi, '')
          .replace(/<thinking>[\s\S]*?<\/thinking>/gi, '')
          .replace(/\[think\][\s\S]*?\[\/think\]/gi, '')
          .replace(/\[thinking\][\s\S]*?\[\/thinking\]/gi, '')
          // Remove internal markers
          .replace(/\[BEGIN FINAL RESPONSE\]/gi, '')
          .replace(/\[END FINAL RESPONSE\]/gi, '')
          .replace(/\[INTERNAL\][\s\S]*?\[\/INTERNAL\]/gi, '')
          // Remove command tags
          .replace(/\[ADD_ALBUM:\s*.+?\s*-\s*.+?\]/g, '')
          .replace(/\[REMOVE_ALBUM:\s*.+?\s*-\s*.+?\]/g, '')
          // Clean up extra whitespace and newlines
          .replace(/\n{3,}/g, '\n\n')
          .trim();

        // If cleaning resulted in empty or very short response, provide fallback
        if (!cleanedMessage || cleanedMessage.length < 5) {
          cleanedMessage = "I've processed your request. Is there anything else I can help with?";
        }

        // Process album additions
        if (albumsToAdd.length > 0) {
          const addedCount = addAlbumsFromChat(albumsToAdd);
          if (addedCount > 0) {
            showMessage(`Added ${addedCount} album(s) to your collection!`, 'success');
          }
        }

        // Process album removals
        if (albumsToRemove.length > 0) {
          const removedCount = removeAlbumsFromChat(albumsToRemove);
          if (removedCount > 0) {
            showMessage(`Removed ${removedCount} album(s) from your collection!`, 'success');
          }
        }

        addMessage(cleanedMessage, 'assistant');
        chatHistory.push({ role: 'assistant', content: cleanedMessage });

      } catch (error) {
        hideTyping();
        console.error('Chat error:', error);
        // Show user-friendly error message
        addMessage("Sorry, I had trouble processing that. Could you try rephrasing your request?", 'assistant');
      }

      sendBtn.disabled = false;
      input.focus();
    }

    // Initialize chat when page loads
    window.addEventListener('DOMContentLoaded', initChat);
  </script>
</body>
</html>

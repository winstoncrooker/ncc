<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#1db954" />
  <meta name="description" content="Track and manage your vinyl record collection" />
  <title>My Collection - Vinyl Vault</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect fill='%230e0e0e' width='100' height='100' rx='20'/><text x='50' y='65' font-size='50' text-anchor='middle' fill='%231db954'>üéµ</text></svg>" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&family=Montserrat:wght@300;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="style.css" />
  <link rel="stylesheet" href="css/auth.css" />
  <style>
    .upload-section {
      max-width: 800px;
      margin: 0 auto;
      text-align: center;
      padding: 40px 20px;
    }

    .upload-section h1 {
      font-size: 2rem;
      color: #1db954;
      margin-bottom: 20px;
    }

    .alpha-badge {
      display: inline-block;
      background: #1db954;
      color: #0e0e0e;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 600;
      margin-bottom: 20px;
    }

    .upload-instructions {
      background: #1a1a1a;
      border: 2px dashed #1db954;
      border-radius: 10px;
      padding: 30px;
      margin: 30px 0;
    }

    .upload-instructions p {
      color: #aaa;
      line-height: 1.6;
      margin: 10px 0;
    }

    .upload-instructions strong {
      color: #1db954;
    }

    .upload-box {
      background: #1a1a1a;
      border: 3px dashed #555;
      border-radius: 15px;
      padding: 50px 30px;
      margin: 30px 0;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .upload-box:hover {
      border-color: #1db954;
      background: #222;
    }

    .upload-box.drag-over {
      border-color: #1db954;
      background: #222;
      transform: scale(1.02);
    }

    .upload-box i {
      font-size: 3rem;
      color: #1db954;
      margin-bottom: 15px;
    }

    .upload-box p {
      color: #aaa;
      margin: 10px 0;
    }

    .upload-box .browse-btn {
      display: inline-block;
      background: #1db954;
      color: #0e0e0e;
      padding: 12px 30px;
      border-radius: 25px;
      font-weight: 600;
      margin-top: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .upload-box .browse-btn:hover {
      background: #1ed760;
      transform: scale(1.05);
    }

    #fileInput {
      display: none;
    }

    .search-section {
      max-width: 600px;
      margin: 30px auto;
    }

    .search-box {
      width: 100%;
      padding: 15px 20px;
      border: 2px solid #333;
      border-radius: 25px;
      background: #1a1a1a;
      color: #eee;
      font-size: 1rem;
      transition: all 0.3s ease;
    }

    .search-box:focus {
      outline: none;
      border-color: #1db954;
      background: #222;
    }

    .collection-list {
      max-width: 800px;
      margin: 30px auto;
      background: #1a1a1a;
      border-radius: 15px;
      padding: 30px;
    }

    .collection-list h2 {
      color: #1db954;
      margin-bottom: 20px;
      font-size: 1.5rem;
    }

    /* Album Grid Styles */
    .collection-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 20px;
      padding: 20px 0;
    }

    .album-card {
      background: #1a1a1a;
      border-radius: 12px;
      transition: all 0.3s ease;
      position: relative;
    }

    .album-card:hover {
      transform: translateY(-8px);
      box-shadow: 0 15px 40px rgba(29, 185, 84, 0.3);
    }

    .album-card .cover-container {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      background: #222;
      overflow: hidden;
      border-radius: 12px 12px 0 0;
    }

    .album-card .cover {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.3s ease;
    }

    .album-card:hover .cover {
      transform: scale(1.1);
    }

    .album-card .loading-cover {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, #1a1a1a 0%, #2a2a2a 100%);
      color: #555;
      font-size: 3rem;
    }

    .album-card .album-info {
      padding: 12px;
      text-align: center;
    }

    .album-card .artist {
      color: #1db954;
      font-weight: 600;
      font-size: 0.9rem;
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .album-card .album-title {
      color: #ccc;
      font-size: 0.8rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .album-card .price {
      color: #1db954;
      font-weight: 600;
      font-size: 0.85rem;
      margin-top: 6px;
    }

    .album-card .delete-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(211, 47, 47, 0.9);
      color: white;
      border: none;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1rem;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 10;
      pointer-events: auto;
    }

    .album-card:hover .delete-btn {
      opacity: 1;
    }

    .album-card .delete-btn:hover {
      background: #f44336;
      transform: scale(1.1);
    }

    @media (max-width: 600px) {
      .collection-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }
    }

    .empty-state {
      text-align: center;
      padding: 60px 20px;
      color: #666;
    }

    .empty-state i {
      font-size: 4rem;
      margin-bottom: 20px;
    }

    .status-message {
      max-width: 600px;
      margin: 20px auto;
      padding: 15px 25px;
      border-radius: 10px;
      text-align: center;
      font-weight: 600;
      display: none;
    }

    .status-message.success {
      background: rgba(29, 185, 84, 0.2);
      border: 2px solid #1db954;
      color: #1db954;
    }

    .status-message.error {
      background: rgba(211, 47, 47, 0.2);
      border: 2px solid #d32f2f;
      color: #f44336;
    }

    .clear-all-btn {
      background: #d32f2f;
      color: white;
      border: none;
      padding: 10px 25px;
      border-radius: 20px;
      cursor: pointer;
      font-weight: 600;
      margin-top: 20px;
      transition: all 0.3s ease;
    }

    .clear-all-btn:hover {
      background: #f44336;
      transform: scale(1.05);
    }

    @media (max-width: 800px) {
      .upload-section h1 {
        font-size: 1.5rem;
      }

      .collection-item {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
      }
    }

    /* AI Chat Styles */
    .chat-container {
      max-width: 800px;
      margin: 30px auto;
      background: #1a1a1a;
      border-radius: 15px;
      overflow: hidden;
      border: 2px solid #333;
    }

    .chat-header {
      background: linear-gradient(135deg, #1db954 0%, #169c46 100%);
      padding: 15px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: pointer;
    }

    .chat-header h3 {
      margin: 0;
      color: #000;
      font-size: 1.1rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .chat-toggle {
      background: none;
      border: none;
      color: #000;
      font-size: 1.5rem;
      cursor: pointer;
      transition: transform 0.3s;
    }

    .chat-toggle.collapsed {
      transform: rotate(180deg);
    }

    .chat-body {
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .chat-body.collapsed {
      max-height: 0;
    }

    .chat-messages {
      height: 300px;
      overflow-y: auto;
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .chat-message {
      max-width: 85%;
      padding: 12px 16px;
      border-radius: 15px;
      line-height: 1.5;
      font-size: 0.95rem;
    }

    .chat-message.user {
      background: #1db954;
      color: #000;
      align-self: flex-end;
      border-bottom-right-radius: 5px;
    }

    .chat-message.assistant {
      background: #333;
      color: #fff;
      align-self: flex-start;
      border-bottom-left-radius: 5px;
    }

    .chat-message.thinking {
      background: #333;
      color: #888;
      align-self: flex-start;
      font-style: italic;
    }

    .chat-message.error {
      background: #d32f2f;
      color: #fff;
      align-self: center;
    }

    .chat-input-container {
      display: flex;
      gap: 10px;
      padding: 15px 20px;
      background: #222;
      border-top: 1px solid #333;
    }

    .chat-input {
      flex: 1;
      padding: 12px 16px;
      border: 2px solid #333;
      border-radius: 25px;
      background: #1a1a1a;
      color: #fff;
      font-size: 0.95rem;
      font-family: 'Montserrat', sans-serif;
    }

    .chat-input:focus {
      outline: none;
      border-color: #1db954;
    }

    .chat-input::placeholder {
      color: #666;
    }

    .chat-send {
      padding: 12px 24px;
      background: #1db954;
      color: #000;
      border: none;
      border-radius: 25px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      font-family: 'Montserrat', sans-serif;
    }

    .chat-send:hover {
      background: #1ed760;
      transform: scale(1.05);
    }

    .chat-send:disabled {
      background: #555;
      cursor: not-allowed;
      transform: none;
    }

    .api-key-setup {
      padding: 20px;
      text-align: center;
    }

    .api-key-setup p {
      color: #aaa;
      margin-bottom: 15px;
      font-size: 0.9rem;
    }

    .api-key-input {
      width: 100%;
      max-width: 400px;
      padding: 12px 16px;
      border: 2px solid #333;
      border-radius: 8px;
      background: #0e0e0e;
      color: #fff;
      font-family: monospace;
      margin-bottom: 15px;
    }

    .api-key-input:focus {
      outline: none;
      border-color: #1db954;
    }

    .api-key-btn {
      padding: 10px 25px;
      background: #1db954;
      color: #000;
      border: none;
      border-radius: 20px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
    }

    .api-key-btn:hover {
      background: #1ed760;
    }

    .typing-indicator {
      display: flex;
      gap: 5px;
      padding: 15px;
    }

    .typing-indicator span {
      width: 8px;
      height: 8px;
      background: #1db954;
      border-radius: 50%;
      animation: typing 1.4s infinite;
    }

    .typing-indicator span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-indicator span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-10px); }
    }
  </style>
</head>
<body>
  <nav id="mainNav">
    <button class="hamburger" id="hamburger" aria-label="Menu">
      <span></span><span></span><span></span>
    </button>
    <div class="nav-links" id="navLinks">
      <a href="index.html">Home</a>
      <a href="stats.html">üìä Stats</a>
      <a href="mycollection.html">üìù My Collection</a>
      <a href="genre.html?genre=rock">Rock</a>
      <a href="genre.html?genre=blues">Blues</a>
      <a href="genre.html?genre=metal">Metal</a>
      <a href="genre.html?genre=pop">Pop</a>
      <a href="genre.html?genre=jazz">Jazz</a>
      <a href="genre.html?genre=soul">Soul</a>
      <a href="genre.html?genre=funk">Funk</a>
      <a href="genre.html?genre=country">Country</a>
      <a href="genre.html?genre=hiphop">Hip-Hop</a>
      <a href="genre.html?genre=folk">Folk</a>
      <a href="genre.html?genre=classical">Classical</a>
      <a href="genre.html?genre=experimental">Experimental</a>
      <a href="genre.html?genre=comedy">Comedy</a>
    </div>
  </nav>

  <!-- Auth Header -->
  <div id="authContainer" class="auth-container">
    <!-- Login button or user profile will be inserted here by auth.js -->
  </div>

  <section class="upload-section">
    <h1>Add Your Own Collection</h1>
    <div class="alpha-badge">ALPHA MODE</div>
    
    <div class="upload-instructions">
      <p><strong>Upload a PDF or TXT file with your collection</strong></p>
      <p>Format: <strong>Artist - Album</strong> (one per line)</p>
      <p style="color: #1db954; margin-top: 15px;"><strong>Example:</strong></p>
      <p style="background: #222; padding: 15px; border-radius: 8px; font-family: monospace; line-height: 1.8;">
        Nirvana - Nevermind<br>
        Funkadelic - Maggot Brain<br>
        Pink Floyd - Dark Side of the Moon
      </p>
      <p style="color: #aaa; font-size: 0.9rem; margin-top: 10px;">Each entry must be on its own line with Artist - Album format</p>
    </div>

    <div id="statusMessage" class="status-message"></div>

    <div class="upload-box" id="uploadBox">
      <div style="font-size: 3rem; margin-bottom: 15px;">üìÑ</div>
      <p style="font-size: 1.1rem; color: #eee; margin-bottom: 5px;">Drag & Drop your PDF or TXT file here</p>
      <p style="color: #666;">or</p>
      <div class="browse-btn" onclick="document.getElementById('fileInput').click()">
        Browse Files
      </div>
      <input type="file" id="fileInput" accept=".txt,.pdf" />
    </div>

    <div class="search-section" id="searchSection" style="display: none;">
      <input 
        type="text" 
        id="searchBox" 
        class="search-box" 
        placeholder="üîç Search for artist or album..."
      />
    </div>

    <div class="collection-list" id="collectionList" style="display: none;">
      <h2>Your Collection (<span id="collectionCount">0</span> albums) <span id="collectionValue" style="font-size: 0.8em; color: #1db954;"></span></h2>
      <div class="collection-grid" id="collectionItems"></div>
      <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 20px;">
        <button class="clear-all-btn" style="background: #1db954;" onclick="fetchAllAlbumData(true)">Refresh Covers & Prices</button>
        <button class="clear-all-btn" style="background: #2196f3;" onclick="exportCollection('json')">Export JSON</button>
        <button class="clear-all-btn" style="background: #2196f3;" onclick="exportCollection('csv')">Export CSV</button>
        <button class="clear-all-btn" style="background: #9c27b0;" onclick="document.getElementById('importInput').click()">Import JSON</button>
        <button class="clear-all-btn" onclick="clearCollection()">Clear All</button>
      </div>
      <input type="file" id="importInput" accept=".json" style="display: none;" onchange="importCollection(event)" />
    </div>

    <div class="empty-state" id="emptyState">
      <div style="font-size: 4rem; margin-bottom: 20px;">üéµ</div>
      <p>Upload a PDF or TXT file to start building your collection</p>
    </div>

    <!-- AI Chat Assistant -->
    <div class="chat-container" id="chatContainer">
      <div class="chat-header" onclick="toggleChat()">
        <h3>ü§ñ AI Collection Assistant</h3>
        <button class="chat-toggle" id="chatToggle">‚ñº</button>
      </div>
      <div class="chat-body" id="chatBody">
        <!-- Chat Interface -->
        <div id="chatInterface">
          <div class="chat-messages" id="chatMessages">
            <div class="chat-message assistant">
              Hi! I'm your vinyl collection assistant powered by Apriel. Ask me anything about your collection, or tell me about albums you want to add!
            </div>
          </div>
          <div class="chat-input-container">
            <input
              type="text"
              class="chat-input"
              id="chatInput"
              placeholder="Ask about your collection..."
              onkeypress="if(event.key === 'Enter') sendMessage()"
            />
            <button class="chat-send" id="chatSend" onclick="sendMessage()">Send</button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <footer>¬© 2025 Vinyl Vault - My Collection (Alpha)</footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.6/purify.min.js"></script>
  <script src="js/config.js"></script>
  <script src="js/auth.js"></script>
  <script>
    // Set up PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    let userCollection = [];

    // Load collection from localStorage on page load
    window.addEventListener('DOMContentLoaded', () => {
      loadCollection();
      setupEventListeners();
      setupAuth();
    });

    // Set up authentication UI
    function setupAuth() {
      const authContainer = document.getElementById('authContainer');
      if (!authContainer) return;

      function updateAuthUI() {
        authContainer.innerHTML = '';

        if (Auth.isAuthenticated()) {
          const user = Auth.getUser();
          const profile = document.createElement('div');
          profile.className = 'user-profile';

          if (user?.picture) {
            profile.innerHTML = `
              <img src="${user.picture}" alt="${user.name || user.email}" class="user-avatar" />
              <span class="user-name">${user.name || user.email}</span>
              <button class="logout-btn" onclick="Auth.logout(); location.reload();">Sign out</button>
            `;
          } else {
            profile.innerHTML = `
              <span class="user-name">${user?.email || 'User'}</span>
              <button class="logout-btn" onclick="Auth.logout(); location.reload();">Sign out</button>
            `;
          }
          authContainer.appendChild(profile);
        } else {
          const loginBtn = Auth.createLoginButton('Sign in with Google', window.location.href);
          authContainer.appendChild(loginBtn);
        }
      }

      // Initial render
      updateAuthUI();

      // Listen for auth events
      window.addEventListener('auth:success', updateAuthUI);
      window.addEventListener('auth:logout', updateAuthUI);
    }

    function setupEventListeners() {
      const uploadBox = document.getElementById('uploadBox');
      const fileInput = document.getElementById('fileInput');
      const searchBox = document.getElementById('searchBox');

      // File input change
      fileInput.addEventListener('change', handleFileSelect);

      // Drag and drop
      uploadBox.addEventListener('dragover', (e) => {
        e.preventDefault();
        uploadBox.classList.add('drag-over');
      });

      uploadBox.addEventListener('dragleave', () => {
        uploadBox.classList.remove('drag-over');
      });

      uploadBox.addEventListener('drop', (e) => {
        e.preventDefault();
        uploadBox.classList.remove('drag-over');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          handleFile(files[0]);
        }
      });

      // Search functionality
      searchBox.addEventListener('input', (e) => {
        filterCollection(e.target.value);
      });

      // Hamburger menu
      const hamburger = document.getElementById('hamburger');
      const navLinks = document.getElementById('navLinks');
      
      if (hamburger && navLinks) {
        hamburger.addEventListener('click', () => {
          hamburger.classList.toggle('active');
          navLinks.classList.toggle('active');
          document.body.classList.toggle('menu-open');
        });
        
        document.addEventListener('click', (e) => {
          if (!e.target.closest('nav')) {
            hamburger.classList.remove('active');
            navLinks.classList.remove('active');
            document.body.classList.remove('menu-open');
          }
        });
        
        navLinks.querySelectorAll('a').forEach(link => {
          link.addEventListener('click', () => {
            hamburger.classList.remove('active');
            navLinks.classList.remove('active');
            document.body.classList.remove('menu-open');
          });
        });
      }
    }

    function handleFileSelect(e) {
      const file = e.target.files[0];
      if (file) {
        handleFile(file);
      }
    }

    async function handleFile(file) {
      const fileName = file.name.toLowerCase();
      const isPDF = fileName.endsWith('.pdf');
      const isTXT = fileName.endsWith('.txt');

      if (!isPDF && !isTXT) {
        showMessage('Please upload a .pdf or .txt file', 'error');
        return;
      }

      showMessage(isPDF ? 'Extracting text from PDF...' : 'Processing file...', 'success');

      try {
        let text;
        if (isPDF) {
          text = await extractTextFromPDF(file);
        } else {
          text = await file.text();
        }

        const { entries, totalLines, skippedLines } = parseEntriesWithStats(text);

        if (entries.length === 0) {
          showMessage('No valid entries found. Use format: Artist - Album (one per line)', 'error');
          return;
        }

        userCollection = entries;
        saveCollection();
        displayCollection();

        let message = `Successfully imported ${entries.length} albums!`;
        if (skippedLines > 0) {
          message += ` (${skippedLines} lines skipped)`;
        }
        showMessage(message, 'success');

        // Auto-fetch album covers and prices from Discogs
        onAlbumsAdded();
      } catch (error) {
        console.error('Error processing file:', error);
        showMessage('Error processing file. Please try again.', 'error');
      }
    }

    async function extractTextFromPDF(file) {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
      let fullText = '';
      const totalPages = pdf.numPages;

      for (let i = 1; i <= totalPages; i++) {
        showMessage(`Extracting page ${i} of ${totalPages}...`, 'success');
        const page = await pdf.getPage(i);
        const textContent = await page.getTextContent();

        // Extract text while preserving line breaks based on Y position
        let lastY = null;
        let lineText = '';

        for (const item of textContent.items) {
          // Get Y position from transform matrix (item.transform[5])
          const currentY = item.transform[5];

          // If Y position changed significantly, it's a new line
          if (lastY !== null && Math.abs(currentY - lastY) > 5) {
            fullText += lineText.trim() + '\n';
            lineText = '';
          }

          lineText += item.str + ' ';
          lastY = currentY;
        }

        // Add the last line of the page
        if (lineText.trim()) {
          fullText += lineText.trim() + '\n';
        }
      }

      showMessage('Processing extracted text...', 'success');
      return fullText;
    }

    function parseEntriesWithStats(text) {
      const lines = text.split('\n');
      const entries = [];
      let totalLines = 0;
      let skippedLines = 0;

      for (let line of lines) {
        line = line.trim();
        if (!line) continue;

        totalLines++;

        // Only accept "Artist - Album" format
        const match = line.match(/^(.+?)\s*-\s*(.+)$/);
        if (match) {
          const artist = match[1].trim();
          const album = match[2].trim();
          if (artist && album) {
            entries.push({ artist, album });
          } else {
            skippedLines++;
          }
        } else {
          skippedLines++;
        }
      }

      return { entries, totalLines, skippedLines };
    }

    function displayCollection() {
      const collectionList = document.getElementById('collectionList');
      const emptyState = document.getElementById('emptyState');
      const searchSection = document.getElementById('searchSection');

      if (userCollection.length === 0) {
        collectionList.style.display = 'none';
        searchSection.style.display = 'none';
        emptyState.style.display = 'block';
        return;
      }

      collectionList.style.display = 'block';
      searchSection.style.display = 'block';
      emptyState.style.display = 'none';

      renderCollection(userCollection);
    }

    function renderCollection(items) {
      const collectionItems = document.getElementById('collectionItems');
      const collectionCount = document.getElementById('collectionCount');
      const collectionValue = document.getElementById('collectionValue');

      collectionCount.textContent = items.length;
      collectionItems.innerHTML = '';

      // Calculate total value
      let totalValue = 0;
      items.forEach(entry => {
        if (entry.price && typeof entry.price === 'number') {
          totalValue += entry.price;
        }
      });

      if (totalValue > 0) {
        collectionValue.textContent = `‚Ä¢ Est. Value: $${totalValue.toFixed(2)}`;
      } else {
        collectionValue.textContent = '';
      }

      items.forEach((entry, index) => {
        const card = document.createElement('div');
        card.className = 'album-card';

        const coverUrl = entry.cover || '';
        const priceDisplay = entry.price ? `$${entry.price.toFixed(2)}` : '';
        const isLoading = entry.loading === true;

        card.innerHTML = `
          <div class="cover-container">
            ${coverUrl
              ? `<img class="cover" src="${coverUrl}" alt="${escapeHtml(entry.album)}" loading="lazy" onerror="this.parentElement.innerHTML='<div class=\\'loading-cover\\'>üíø</div>'">`
              : `<div class="loading-cover">${isLoading ? '‚è≥' : 'üíø'}</div>`
            }
          </div>
          <div class="album-info">
            <div class="artist" title="${escapeHtml(entry.artist)}">${escapeHtml(entry.artist)}</div>
            <div class="album-title" title="${escapeHtml(entry.album)}">${escapeHtml(entry.album)}</div>
            ${priceDisplay ? `<div class="price">${priceDisplay}</div>` : ''}
          </div>
          <button class="delete-btn" onclick="deleteItem(${index})" title="Remove">√ó</button>
        `;
        collectionItems.appendChild(card);
      });
    }

    function filterCollection(query) {
      if (!query) {
        renderCollection(userCollection);
        return;
      }

      const lowerQuery = query.toLowerCase();
      const filtered = userCollection.filter(entry => 
        entry.artist.toLowerCase().includes(lowerQuery) ||
        entry.album.toLowerCase().includes(lowerQuery)
      );

      renderCollection(filtered);
    }

    function deleteItem(index) {
      console.log('deleteItem called with index:', index);
      userCollection.splice(index, 1);
      saveCollection();
      displayCollection();
      showMessage('Album removed', 'success');
    }

    function clearCollection() {
      console.log('clearCollection called');
      userCollection = [];
      saveCollection();
      displayCollection();
      document.getElementById('searchBox').value = '';
      showMessage('Collection cleared', 'success');
    }

    function saveCollection() {
      localStorage.setItem('userCollection', JSON.stringify(userCollection));
    }

    function loadCollection() {
      const saved = localStorage.getItem('userCollection');
      if (saved) {
        try {
          userCollection = JSON.parse(saved);
          displayCollection();
          // Auto-fetch missing album data on page load
          const hasMissingData = userCollection.some(entry => !entry.cover);
          if (hasMissingData) {
            onAlbumsAdded();
          }
        } catch (e) {
          console.error('Error loading collection:', e);
          userCollection = [];
        }
      }
    }

    function showMessage(text, type) {
      const message = document.getElementById('statusMessage');
      message.textContent = text;
      message.className = `status-message ${type}`;
      message.style.display = 'block';

      setTimeout(() => {
        message.style.display = 'none';
      }, 4000);
    }

    // Export collection to JSON or CSV
    function exportCollection(format) {
      if (userCollection.length === 0) {
        showMessage('No collection to export', 'error');
        return;
      }

      let content, filename, mimeType;
      const timestamp = new Date().toISOString().split('T')[0];

      if (format === 'json') {
        content = JSON.stringify(userCollection, null, 2);
        filename = `vinyl-vault-collection-${timestamp}.json`;
        mimeType = 'application/json';
      } else if (format === 'csv') {
        const headers = ['Artist', 'Album', 'Year', 'Price'];
        const rows = userCollection.map(item => [
          `"${(item.artist || '').replace(/"/g, '""')}"`,
          `"${(item.album || '').replace(/"/g, '""')}"`,
          item.year || '',
          item.price || ''
        ].join(','));
        content = [headers.join(','), ...rows].join('\n');
        filename = `vinyl-vault-collection-${timestamp}.csv`;
        mimeType = 'text/csv';
      }

      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);

      showMessage(`Collection exported as ${format.toUpperCase()}`, 'success');
    }

    // Import collection from JSON
    async function importCollection(event) {
      const file = event.target.files[0];
      if (!file) return;

      try {
        const text = await file.text();
        const imported = JSON.parse(text);

        if (!Array.isArray(imported)) {
          throw new Error('Invalid format');
        }

        // Validate and merge
        let addedCount = 0;
        for (const item of imported) {
          if (item.artist && item.album) {
            const exists = userCollection.some(
              existing => existing.artist.toLowerCase() === item.artist.toLowerCase() &&
                         existing.album.toLowerCase() === item.album.toLowerCase()
            );
            if (!exists) {
              userCollection.push({
                artist: item.artist,
                album: item.album,
                cover: item.cover || null,
                year: item.year || null,
                price: item.price || null,
                discogsId: item.discogsId || null
              });
              addedCount++;
            }
          }
        }

        saveCollection();
        displayCollection();
        showMessage(`Imported ${addedCount} new album(s)`, 'success');

        // Fetch missing covers
        if (addedCount > 0) {
          onAlbumsAdded();
        }
      } catch (error) {
        console.error('Import error:', error);
        showMessage('Invalid JSON file. Please export from Vinyl Vault.', 'error');
      }

      // Reset input
      event.target.value = '';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================
    // Discogs API Integration (via Caching Server)
    // ============================================

    // Use local server for caching (falls back to direct API if server unavailable)
    const CACHE_SERVER_URL = 'http://localhost:5001';
    let useLocalServer = true;

    // Direct Discogs API (fallback)
    const DISCOGS_API_URL = 'https://api.discogs.com';
    const DISCOGS_KEY = 'yRxzvHyveKiFOEHuwmcW';
    const DISCOGS_SECRET = 'GnnPcnLGovdJLMfMyEpaSRoXOsRqojBr';

    // Rate limiting for direct Discogs API
    let lastDiscogsRequest = 0;
    const DISCOGS_RATE_LIMIT = 1100;

    async function waitForRateLimit() {
      const now = Date.now();
      const timeSinceLastRequest = now - lastDiscogsRequest;
      if (timeSinceLastRequest < DISCOGS_RATE_LIMIT) {
        await new Promise(resolve => setTimeout(resolve, DISCOGS_RATE_LIMIT - timeSinceLastRequest));
      }
      lastDiscogsRequest = Date.now();
    }

    // Search via caching server (preferred)
    async function searchViaServer(artist, album) {
      const url = `${CACHE_SERVER_URL}/api/discogs/search?artist=${encodeURIComponent(artist)}&album=${encodeURIComponent(album)}`;

      try {
        const response = await fetch(url);
        if (!response.ok) {
          if (response.status === 404) return null;
          throw new Error(`Server error: ${response.status}`);
        }
        return await response.json();
      } catch (error) {
        console.log('Cache server unavailable, falling back to direct API');
        useLocalServer = false;
        return null;
      }
    }

    // Direct Discogs search (fallback)
    async function searchDiscogsDirect(artist, album) {
      await waitForRateLimit();

      const query = encodeURIComponent(`${artist} ${album}`);
      const url = `${DISCOGS_API_URL}/database/search?q=${query}&type=release&key=${DISCOGS_KEY}&secret=${DISCOGS_SECRET}`;

      try {
        const response = await fetch(url, {
          headers: { 'User-Agent': 'VinylVault/1.0' }
        });

        if (!response.ok) return null;

        const data = await response.json();
        if (!data.results?.length) return null;

        const bestMatch = data.results.find(r =>
          r.title.toLowerCase().includes(artist.toLowerCase()) &&
          r.title.toLowerCase().includes(album.toLowerCase())
        ) || data.results[0];

        return {
          id: bestMatch.id,
          cover: bestMatch.cover_image || bestMatch.thumb,
          title: bestMatch.title,
          year: bestMatch.year
        };
      } catch (error) {
        console.error('Discogs search error:', error);
        return null;
      }
    }

    // Get price from direct API (fallback)
    async function getDiscogsPriceDirect(releaseId) {
      await waitForRateLimit();

      try {
        const url = `${DISCOGS_API_URL}/releases/${releaseId}?key=${DISCOGS_KEY}&secret=${DISCOGS_SECRET}`;
        const response = await fetch(url, {
          headers: { 'User-Agent': 'VinylVault/1.0' }
        });

        if (!response.ok) return null;
        const data = await response.json();
        return data.lowest_price || null;
      } catch (error) {
        return null;
      }
    }

    // Fetch album data (uses server cache when available)
    async function fetchAlbumData(index) {
      const entry = userCollection[index];
      if (!entry || entry.cover) return;

      entry.loading = true;
      renderCollection(userCollection);

      try {
        let result = null;

        // Try caching server first
        if (useLocalServer) {
          result = await searchViaServer(entry.artist, entry.album);
        }

        // Fallback to direct API
        if (!result && !useLocalServer) {
          result = await searchDiscogsDirect(entry.artist, entry.album);
          if (result) {
            const price = await getDiscogsPriceDirect(result.id);
            result.price = price;
          }
        }

        if (result) {
          entry.cover = result.cover;
          entry.discogsId = result.id;
          entry.year = result.year;
          if (result.price) entry.price = result.price;
        }
      } catch (error) {
        console.error('Error fetching album data:', error);
      }

      entry.loading = false;
      saveCollection();
      renderCollection(userCollection);
    }

    // Fetch data for all albums (forceRefresh=true will re-fetch even if cover exists)
    async function fetchAllAlbumData(forceRefresh = false) {
      console.log('fetchAllAlbumData called, forceRefresh:', forceRefresh);

      let albumsToFetch;
      if (forceRefresh) {
        // Clear existing data and re-fetch all
        userCollection.forEach(entry => {
          delete entry.cover;
          delete entry.price;
          delete entry.discogsId;
          delete entry.year;
        });
        saveCollection();
        displayCollection();
        albumsToFetch = userCollection.map((entry, index) => ({ entry, index }));
      } else {
        albumsToFetch = userCollection
          .map((entry, index) => ({ entry, index }))
          .filter(({ entry }) => !entry.cover && !entry.loading);
      }

      if (albumsToFetch.length === 0) {
        showMessage('All albums already have data. Click again to force refresh.', 'success');
        return;
      }

      showMessage(`Fetching data for ${albumsToFetch.length} album(s)...`, 'success');

      for (const { index } of albumsToFetch) {
        await fetchAlbumData(index);
      }

      showMessage(`Album data updated!`, 'success');
    }

    // Auto-fetch data when albums are added
    function onAlbumsAdded() {
      // Small delay to let UI update first
      setTimeout(() => {
        fetchAllAlbumData();
      }, 500);
    }

    // ============================================
    // AI Chat Assistant Functions (via Worker API)
    // ============================================

    let chatHistory = [];

    // Initialize chat on page load
    function initChat() {
      // Chat is ready - Worker handles API key
      document.getElementById('chatInterface').style.display = 'block';
    }

    // Toggle chat panel
    function toggleChat() {
      const chatBody = document.getElementById('chatBody');
      const chatToggle = document.getElementById('chatToggle');
      chatBody.classList.toggle('collapsed');
      chatToggle.classList.toggle('collapsed');
    }


    // Add message to chat (with XSS sanitization)
    function addMessage(text, role) {
      const messagesDiv = document.getElementById('chatMessages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `chat-message ${role}`;
      // Sanitize text to prevent XSS attacks
      messageDiv.textContent = typeof DOMPurify !== 'undefined' ? DOMPurify.sanitize(text, {ALLOWED_TAGS: []}) : text;
      messagesDiv.appendChild(messageDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Add typing indicator
    function showTyping() {
      const messagesDiv = document.getElementById('chatMessages');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'chat-message thinking';
      typingDiv.id = 'typingIndicator';
      typingDiv.innerHTML = '<div class="typing-indicator"><span></span><span></span><span></span></div>';
      messagesDiv.appendChild(typingDiv);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // Remove typing indicator
    function hideTyping() {
      const typing = document.getElementById('typingIndicator');
      if (typing) typing.remove();
    }


    // Add albums from chat response
    function addAlbumsFromChat(albums) {
      let addedCount = 0;

      for (const album of albums) {
        // Check if album already exists
        const exists = userCollection.some(
          item => item.artist.toLowerCase() === album.artist.toLowerCase() &&
                  item.album.toLowerCase() === album.album.toLowerCase()
        );

        if (!exists) {
          userCollection.push(album);
          addedCount++;
        }
      }

      if (addedCount > 0) {
        saveCollection();
        displayCollection();
        // Auto-fetch album covers and prices from Discogs
        onAlbumsAdded();
      }

      return addedCount;
    }

    // Remove albums from chat response
    function removeAlbumsFromChat(albums) {
      let removedCount = 0;

      for (const albumToRemove of albums) {
        const index = userCollection.findIndex(
          item => item.artist.toLowerCase() === albumToRemove.artist.toLowerCase() &&
                  item.album.toLowerCase() === albumToRemove.album.toLowerCase()
        );

        if (index !== -1) {
          userCollection.splice(index, 1);
          removedCount++;
        }
      }

      if (removedCount > 0) {
        saveCollection();
        displayCollection();
      }

      return removedCount;
    }

    // Send message via Worker API (proxied to Together.ai)
    async function sendMessage() {
      const input = document.getElementById('chatInput');
      const sendBtn = document.getElementById('chatSend');
      const userMessage = input.value.trim();

      if (!userMessage) return;

      // Add user message to chat
      addMessage(userMessage, 'user');
      input.value = '';
      sendBtn.disabled = true;

      // Add to history
      chatHistory.push({ role: 'user', content: userMessage });

      // Show typing indicator
      showTyping();

      try {
        const response = await fetch(`${CONFIG.API_BASE}/api/chat/`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            message: userMessage,
            collection: userCollection.map(item => ({ artist: item.artist, album: item.album }))
          })
        });

        hideTyping();

        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.detail || `API error: ${response.status}`);
        }

        const data = await response.json();
        const cleanedMessage = data.response || 'Sorry, I could not generate a response.';

        // Worker returns parsed album actions directly
        const albumsToAdd = data.albums_to_add || [];
        const albumsToRemove = data.albums_to_remove || [];

        // Process album additions
        if (albumsToAdd.length > 0) {
          const addedCount = addAlbumsFromChat(albumsToAdd);
          if (addedCount > 0) {
            showMessage(`Added ${addedCount} album(s) to your collection!`, 'success');
          }
        }

        // Process album removals
        if (albumsToRemove.length > 0) {
          const removedCount = removeAlbumsFromChat(albumsToRemove);
          if (removedCount > 0) {
            showMessage(`Removed ${removedCount} album(s) from your collection!`, 'success');
          }
        }

        addMessage(cleanedMessage, 'assistant');
        chatHistory.push({ role: 'assistant', content: cleanedMessage });

      } catch (error) {
        hideTyping();
        console.error('Chat error:', error);
        // Show user-friendly error message
        addMessage("Sorry, I had trouble processing that. Could you try rephrasing your request?", 'assistant');
      }

      sendBtn.disabled = false;
      input.focus();
    }

    // Initialize chat when page loads
    window.addEventListener('DOMContentLoaded', initChat);

    // Register service worker for PWA support
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/sw.js')
        .then(reg => console.log('Service Worker registered'))
        .catch(err => console.log('Service Worker registration failed:', err));
    }
  </script>
</body>
</html>
